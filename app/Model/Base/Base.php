<?php

namespace App\Model\Base;

use Carbon\Carbon;
use Illuminate\Database\Eloquent\Model;
use Illuminate\Support\Facades\Cache;
use Illuminate\Support\Facades\DB;

/**
 * Class Base
 * @package App\Model\Base
 */
class Base extends Model
{
    /**
     * @var array
     */
    protected static $_destroyRelations = [];
    /**
     * @var array
     */
    protected static $_updateRelations = ['byDestroy'];
    /**
     * @var bool
     */
    protected $_hasActionBy = false;
    use \App\Model\Scopes\Base\Base;
    use \App\Model\Presenters\Base;
    use AutoFillInsIdUpId;
    /**
     * @var bool
     */
    public $timestamps = true;
    /**
     * @var string
     */
    protected $_alias = '';

    /**
     * @return array
     */
    public static function getDestroyRelations()
    {
        return static::$_destroyRelations;
    }

    /**
     * @param array $destroyRelations
     */
    public static function setDestroyRelations($destroyRelations)
    {
        static::$_destroyRelations = $destroyRelations;
    }

    /**
     * @return array
     */
    public static function getUpdateRelations()
    {
        return array_get(static::$_updateRelations, 0,'') == 'byDestroy' ? self::getDestroyRelations() : static::$_updateRelations;
    }

    /**
     * @param $updateRelations
     */
    public static function setUpdateRelations($updateRelations)
    {
        static::$_updateRelations = $updateRelations;
    }

    /**
     * The attributes that should be mutated to dates.
     *
     * @var array
     */
    public static function getTableName()
    {
        return with(new static)->getTable();
    }


    /**
     * @param $field
     * @return string
     */
    public function getField($field)
    {
        return $this->getTableName() . '.' . $field;
    }

    /**
     * @return string
     */
    public function getAlias()
    {
        return $this->_alias ? $this->_alias : $this->table;
    }

    /**
     * @param string $alias
     */
    public function setAlias($alias)
    {
        $this->_alias = $alias;
    }

    /**
     * @param $key
     * @return array|\Illuminate\Contracts\Translation\Translator|null|string
     */
    public function getAttributeName($key)
    {
        return transa($this->getAlias(), $key);
    }

    /**
     * @param $key
     * @return array|\Illuminate\Contracts\Translation\Translator|null|string
     */
    public function tA($key)
    {
        return transa($this->getAlias(), $key);
    }

    /**
     * @param $key
     * @return array|\Illuminate\Contracts\Translation\Translator|null|string
     */
    public function getModelName($key = 'name')
    {
        return transm($this->getAlias() . '.' . $key);
    }

    /**
     * @return mixed
     */
    public function getCreatedAtColumn()
    {
        return getCreatedAtColumn();
    }

    /**
     * Get the name of the "updated at" column.
     *
     * @return string
     */
    public function getUpdatedAtColumn()
    {
        return getUpdatedAtColumn();
    }

    /**
     * @param $key
     * @return bool
     */
    public function hasAttribute($key)
    {
        return array_key_exists($key, $this->getAttributes());
    }

    /**
     * @param array $options
     * @return bool
     */
    public function save(array $options = [])
    {
        // unset field not exist in db
        $attrs = $this->getAttributes();
        $id = $this->getKeyName();
        $id = $id ? $id : 'id';
        isset($attrs[$id]) && $this->_allowFillActionAt() ? $attrs[getSystemConfig('updated_at_column.field')] = date('Y-m-d H:i:s') : null;
        $this->setRawAttributes([])->fill($attrs);
        return parent::save($options); // TODO: Change the autogenerated stub
    }


    /**
     * @return array
     */
    public function getFillable()
    {
        $fields = parent::getFillable();
        getSystemConfig('updated_at_column.field') ? $fields[] = getSystemConfig('updated_at_column.field') : '';
        return $fields;
    }

    /**
     * @param array $attributes
     * @return $this
     */
    public function fill(array $attributes)
    {
        $key = $this->getKeyName();
        $key = $key ? $key : 'id';
        isset($attributes[$key]) ? $this->$key = $attributes[$key] : null;
        return parent::fill($attributes); // TODO: Change the autogenerated stub
    }

    /**
     * @param $key
     * @return $this
     */
    public function removeAttribute($key)
    {
        unset($this->attributes[$key]);
        return $this;
    }

    /**
     * @param $data
     * @return $this
     */
    public function mergeAttributes($data)
    {
        $this->attributes = array_merge($this->attributes, $data);
        return $this;
    }

    /**
     * @param $column
     * @return string
     */
    public function getQualifiedColumn($column)
    {
        return $this->getTable() . '.' . $column;
    }
    /**
     * @param $column
     * @return string
     */
    public static function getQuaColumn($column)
    {
        return  with(new static)->getQualifiedColumn($column);
    }

    /**
     * @param $key
     * @param int $offset
     * @param array $attr
     * @param bool $resetOffset
     * @return mixed
     */
    public function getRelationOrNew($key, $offset = 0, $attr = [], $resetOffset = false)
    {
        if (!$this->getKey() && empty($this->relationsToArray())) {
            return $this->{$key}()->getRelated()->setRawAttributes($attr);
        }
        try {
            $r = $this->getRelationValue($key);
            if (isCollection($r) && $resetOffset) {
                $r = $r->values();
            }
            $entity = isCollection($r) ? $r->offsetGet($offset) : $r;
            if ($entity) {
                return $entity;
            }
        } catch (\Exception $exception) {

        }
        return $this->{$key}()->getRelated()->setRawAttributes($attr);
    }

    public function removeRelation($key)
    {
        $relations = $this->getRelations();
        unset($relations[$key]);
        $this->setRelations($relations);
        return $this;
    }

    public function removeRelations()
    {
        $this->setRelations([]);
    }

    /**
     * @param $key
     * @param int $offset
     * @param bool $resetOffset
     * @return mixed
     */
    public function tryGet($key, $offset = 0, $resetOffset = false)
    {
        return $this->getRelationOrNew($key, $offset, [], $resetOffset);
    }

    /**
     *
     */
    protected static function boot()
    {
        parent::boot();
        static::deleting(function ($check) {
            try {
                $action = $check->isForceDeleting() ? 'forceDelete' : 'delete';
            } catch (\Exception $exception) {
                $action = 'delete';
            }
            foreach ($check::getDestroyRelations() as $destroyRelation) {
                $related = $check->{$destroyRelation}();
                static::_destroy($related, $action, $check->{$check->getKeyName()});
            }
        });
        static::updating(function ($check) {
            foreach ($check::getUpdateRelations() as $updateRelation) {
                $related = $check->{$updateRelation}();
                static::_update($related, $check->{$check->getKeyName()});
            }
        });
    }

    /**
     * @param $entity
     * @param $action
     * @param $parentIds
     * @return bool
     */
    protected static function _destroy($entity, $action, $parentIds)
    {
        $foreignKey = $entity->getForeignKeyName();
        $related = $entity->getRelated();
        $relations = $related::getDestroyRelations();
        $query = $entity->whereIn($foreignKey, (array)$parentIds)->getQuery();
        //
        if (!$entity->getParentKey()) {
            $wheres = $query->getQuery()->wheres;
            unset($wheres[0]);
            $query->getQuery()->wheres = $wheres;
        }
        //
        if (empty($relations)) {
            $query->{$action}();
            return true;
        }
        //
        $ids = $query->pluck('id')->toArray();
        $query->{$action}();
        foreach ($relations as $destroyRelation) {
            self::_destroy($related->{$destroyRelation}(), $action, $ids);
        }
    }

    /**
     * @param $entity
     * @param $parentIds
     * @return bool
     */
    protected static function _update($entity, $parentIds)
    {
        $foreignKey = $entity->getForeignKeyName();
        $related = $entity->getRelated();
        $relations = $related::getUpdateRelations();
        $query = $entity->whereIn($foreignKey, (array)$parentIds)->getQuery();
        //
        if (!$entity->getParentKey()) {
            $wheres = $query->getQuery()->wheres;
            unset($wheres[0]);
            $query->getQuery()->wheres = $wheres;
        }
        //
        if (empty($relations)) {
            $query->update([getSystemConfig('updated_at_column.field') => Carbon::create()]);
            return true;
        }
        //
        $ids = $query->pluck('id')->toArray();
        foreach ($relations as $updateRelation) {
            self::_update($related->{$updateRelation}(), $ids);
        }
    }

    public function getNextInsertId()
    {
        $entity = $this;
        if ($entity->id) {
            return $entity->id;
        }
        $nextId = 1;
        $table = $entity->getTable();
        switch (true) {
            case config('database.default') == 'mysql':
                $statement = DB::select("SHOW TABLE STATUS LIKE '{$table}'");
                $nextId = $statement[0]->Auto_increment;
                break;
            case config('database.default') == 'pgsql':
                //@todo fix for pgsql
                break;
            case config('database.default') == 'sqlite':
                //@todo fix for sqlite
                break;
            case config('database.default') == 'sqlsrv':
                //@todo fix for sqlsrv
                break;
        }
        return $nextId;
    }

    protected function fireModelEvent($event, $halt = true)
    {
        if (!isset(static::$dispatcher)) {
            return true;
        }

        // First, we will get the proper method to call on the event dispatcher, and then we
        // will attempt to fire a custom, object based event for the given event. If that
        // returns a result we can return that result, or we'll call the string events.
        $method = $halt ? 'until' : 'fire';

        $result = $this->filterModelEventResults(
            $this->fireCustomModelEvent($event, $method)
        );

        if ($result === false) {
            return false;
        }

        return !empty($result) ? $result : static::$dispatcher->{$method}(
            getConstant('EVENT_MODEL_TYPE') . ".{$event}: " . static::class, $this
        );
    }

    /**
     * Register a model event with the dispatcher.
     *
     * @param  string $event
     * @param  \Closure|string $callback
     * @return void
     */
    protected static function registerModelEvent($event, $callback)
    {
        if (isset(static::$dispatcher)) {
            $name = static::class;

            static::$dispatcher->listen(getConstant('EVENT_MODEL_TYPE') . ".{$event}: {$name}", $callback);
        }
    }

    public function getColumns($qualifiedColumn = false)
    {
        $qualifiedColumnInt = (int)$qualifiedColumn;
        $cacheKey = __FUNCTION__ . $this->getTable() . $qualifiedColumnInt;
        if (Cache::has($cacheKey)) {
            return Cache::get($cacheKey);
        }
        $columns = $this->getConnection()->getSchemaBuilder()->getColumnListing($this->getTable());
        if (!$qualifiedColumn) {
            return $columns;
        }
        $r = [];
        foreach ($columns as $column) {
            $r[$column] = $this->getQualifiedColumn($column);
        }
        Cache::rememberForever($cacheKey, function () use ($r) {
            return $r;
        });
        return $r;
    }
}
